from binaryOps import *
from indexMaps import *
import numpy as np
import scipy.sparse as spr


def total_spin(integer, systemSize, spinValue = 1/2):
    """
    Calculates how many more ones than zeroes there are in the binary representation of given integer. This gives the total spin.

    :param integer: positive integer
    :param systemSize: Size of the system
    :param spinValue (optional): eigenvalue of the spin.
    :return: Total spin in the configuration represented by the binary of that integer
    """

    b = binary(integer).zfill(systemSize)
    zero, one = b.count("0"), b.count("1")
    totalSpin = one - zero
    return totalSpin*spinValue

def swap_unequal_neighbors(integer, index, systemSize):
    """
    In given integers binary representation, swaps the bit at index and the one at index+1, if they are unequal.
    This represents the action of the S+ and S- operator sum in the Hubbard Model.
    Accounts for periodic  boundary conditions by wrapping the index around, i.e. it also swaps last and first bit if those are unequal, as they are considered neighboring.


    :param integer: postive integer
    :param index: index at which to evaluate the bitswap
    :param systemSize: Size of the system to consider periodic BCs
    :return: integer correspnding to the binary representations with swapped  bits.
    """
    b = binary(integer).zfill(systemSize)[::-1] # Reverse the string so that the value at position 0 is the first bit of the binary number.
    if (index == systemSize - 1):
        nextIndex = 0
    else:
        nextIndex = index + 1
    if b[index] != b[nextIndex]:
        x = bitflip(integer, index)
        integer = bitflip(x, nextIndex)
    return integer

def calculate_ladder_operators(integer, systemSize):
    """
    Uses the function swap_unequal_neighbors to calculate the action of the sum of all ladder operators on a given state

    :param integer: positive integer representing a state
    :param systemSize: System size
    :return: List of positive integers corresponding to states that are generated by applying the ladder operators to given state.
    """
    res = []
    for i in range(systemSize):
        swapped = swap_unequal_neighbors(integer,i,systemSize)
        if integer != swapped:
            res.append(swapped)
    return res

def calculate_sz_coupling_index(integer, index, systemSize, spinValue = 1/2):
    b = binary(integer).zfill(systemSize)[::-1]
    product = 1
    if (index == systemSize - 1):
        nextIndex = 0
    else:
        nextIndex = index + 1
    for elem in [b[index],b[nextIndex]]:
        if elem == "0":
            product = product * (-spinValue)
        if elem == "1":
            product = product*spinValue
    return product

def calculate_sz_coupling(integer, systemSize, spinValue = 1/2):
    res = 0
    for i in range(systemSize):
        res = res + calculate_sz_coupling_index(integer,i ,systemSize, spinValue=spinValue)
    return res

def construct_hamiltonian(systemSize, totalSpin = None, spinValue = 1/2, coupling = 1):
    isDict = create_index_to_state(systemSize, totalSpin=totalSpin)
    siDict = create_state_to_index(isDict)

    hSize = len(isDict) # reduced hamiltonian size is only considering a subsystem due to total spin conservation

    H = spr.lil_matrix((hSize,hSize))

    for i in range(hSize):
        H[i,i] = calculate_sz_coupling(isDict[i], systemSize, spinValue = spinValue)
        createdStates = calculate_ladder_operators(isDict[i], systemSize)

        nonzeroEntries = [siDict[state] for state in createdStates]
        for j in nonzeroEntries:
            H[i,j] = 1/2

    return (coupling * H).tocsr()




